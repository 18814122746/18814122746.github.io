<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven入门及POM文件详解]]></title>
    <url>%2F2018%2F06%2F26%2FMaven%E5%85%A5%E9%97%A8%E5%8F%8APOM%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Maven 是基于项目对象模型 POM(project object model) 概念的的 软件项目管理工具。Maven 提供统一标准的开发项目结构，并使用简单的标签描述来配置项目相关信息和管理项目依赖包，可以使开发人员在非常短的时间内完成配置工作，大大提高开发效率。下面介绍 Maven 的一些入门知识。转载请说明出处。 MavenMaven 是什么Maven 是一个项目管理工具，提供一种标准化的方式构建和管理项目。这种标准化包括 统一项目开发目录，所有的项目目录结构统一划分成 src/main/java (源代码目录)、src/main/resources (资源目录)、src/test/java (测试代码目录)、 src/test/resources (测试资源目录)、 target (生成文件目录)等目录。 统一项目的生命周期，规范项目从开始构建到部署的建设过程。 统一管理项目依赖，开发人员只需要定义所需要的依赖包，Maven 会自动搜索依赖包所依赖的其他包，不需要开发人员关心。 测试和构建流程自动化和简单化。 举个简单的例子，在开发过程中我们通常会遇到这样的问题： 在开发中，为了保证编译通过，我们会到处去寻找jar包，当编译通过了，运行的时候，却发现 “ClassNotFoundException” ，我们想到的是，难道还差jar包？ 每个Java项目的目录结构都没有一个统一的标准，配置文件到处都是，单元测试代码到底应该放在那里也没有一个权威的规范。 使用 Maven 可以轻松解决这些问题。 Maven 生命周期参考 Maven Lifecycle，Maven 项目的生命周期大概可分为以下阶段： validate：校验阶段，校验项目的正确性和必要配置信息是否可用。 compile：编译阶段 test：单元测试阶段，单元测试代码不会被 package 和 deploy package：打包阶段，打包成指定格式如 jar 包 verify：集成测试阶段 install：将 jar 包发布到本地仓库 deploy：将 jar 包发布到远程仓库 Maven 常用命令参考 Maven Plugins，Maven 实际上是一个插件的集成框架，Maven 的所有任务都是通过插件来完成的。Maven 包含核心插件和其他插件，其中两种类型的插件可以在 pom.xml 文件配置相关信息： Build 插件：在构建过程中执行，并在 pom.xml 中的 元素进行配置 Reporting 插件：在生成项目描述网站期间执行，在 pom.xml 中的 元素进行配置 Maven 目录参考 Maven 标准目录布局，Maven 标准的目录如下 12345678910111213141516|── pom.xml|── src| |-- main| | ├── java| | ├── resources| | └── filters| ├── test| | ├── java| | ├── resources| | └── filters| ├── it| ├── assembly| └── site├── LICENSE.txt├── NOTICE.txt└── README.txt pom.xml：Maven 的核心配置文件 src/main/java：项目的源代码所在的目录 src/main/resources：项目的资源文件所在的目录 src/main/filters：项目的资源过滤文件所在的目录 src/main/webapp：如果是web项目，则该目录是web应用源代码所在的目录，比如html文件和web.xml等都在该目录下。 src/test/java：测试代码所在的目录 src/test/resources：测试相关的资源文件所在的目录 src/test/filters：测试相关的资源过滤文件所在的目录 下面这些目录平时用的不是很多 src/it：集成测试代码所在的目录，主要是供别的插件使用的。 src/assembly：组件（Assembly）描述符所在的目录 src/site：站点描述文件 LICENSE.txt：项目的许可文件 NOTICE.txt：该项目依赖的库的注意事项 README.txt：项目的readme文件 POMpom.xml 文件是整个 Maven 项目的核心配置文件。pom.xml 文件记录了整个项目的基础配置信息、相关依赖插件、构建配置和远程库等信息。 整体结构12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 基本设置 --&gt; &lt;groupId&gt;...&lt;/groupId&gt; &lt;artifactId&gt;...&lt;/artifactId&gt; &lt;version&gt;...&lt;/version&gt; &lt;packaging&gt;...&lt;/packaging&gt; &lt;dependencies&gt;...&lt;/dependencies&gt; &lt;parent&gt;...&lt;/parent&gt; &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt; &lt;modules&gt;...&lt;/modules&gt; &lt;properties&gt;...&lt;/properties&gt; &lt;!-- 构建过程的设置 --&gt; &lt;build&gt;...&lt;/build&gt; &lt;reporting&gt;...&lt;/reporting&gt; &lt;!-- 项目信息设置 --&gt; &lt;name&gt;...&lt;/name&gt; &lt;description&gt;...&lt;/description&gt; &lt;url&gt;...&lt;/url&gt; &lt;inceptionYear&gt;...&lt;/inceptionYear&gt; &lt;licenses&gt;...&lt;/licenses&gt; &lt;organization&gt;...&lt;/organization&gt; &lt;developers&gt;...&lt;/developers&gt; &lt;contributors&gt;...&lt;/contributors&gt; &lt;!-- 环境设置 --&gt; &lt;issueManagement&gt;...&lt;/issueManagement&gt; &lt;ciManagement&gt;...&lt;/ciManagement&gt; &lt;mailingLists&gt;...&lt;/mailingLists&gt; &lt;scm&gt;...&lt;/scm&gt; &lt;prerequisites&gt;...&lt;/prerequisites&gt; &lt;repositories&gt;...&lt;/repositories&gt; &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt; &lt;distributionManagement&gt;...&lt;/distributionManagement&gt; &lt;profiles&gt;...&lt;/profiles&gt;&lt;/project&gt; 常用标签 modelVersion：必须，POM 模型版本，一般写 4.0.0 版本，该版本是同时被 Maven2 和 Maven3 支持的版本。 groupId：必须，组织编号唯一标识，通常写法是 com.mycompany.app，同时定义了构建时生成的相对路径为 /com/mycompany/app。 artifactId：必须，项目名称唯一标识，写法如 consumer-banking version：必须，项目版本，写法如 2.3.4 groupId、artifactId 和 version 是所有 POM 文件根节点 &lt;project&gt; 里面必须包含的三个字段，共同定义了该项目在仓库里面的坐标位置，这意味着特定的 groupId 下，artifactId 也必须是唯一的。 version 定义为 1.0.0 和 1.0.0-SNAPSHOT 的区别：1.0.0是指稳定版本，只要版本号不变，就算远程库中该版本号的项目进行了更新，也不会去远程库中拉取最新版本的项目，除非把版本号改成 1.1.0 等不同版本号；1.0.0-SNAPSHOT 是指开发版本，每次建立项目时都会去远程库中查看是否有最新版本。 packaging：项目的打包类型，可以为 ja、war、ear、pom 等。 parent：父项目坐标，将继承父项目的依赖和插件等。如一个基于 spring boot 构建的项目需要继承 spring boot 父项目如下： 12345&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt; dependencies：定义了项目相关的所有依赖，每一个依赖包由 &lt;dependency&gt; 包围，&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt; 标签定义了依赖包在仓库中的唯一坐标，Maven 根据该坐标按照 本地仓库 &gt; 中央仓库 &gt; 远程仓库 的查找顺序去查找依赖包。 123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpmime&lt;/artifactId&gt; &lt;version&gt;4.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.6&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; bulid：项目的构建信息 finalName：构建产生的项目名称，默认为 ${artifactId}-${version}。 directory：构建产生的文件的存放目录，默认为 $(basedir}/target ，即项目根目录下的 target 目录。 plugins：插件列表，如下面第一个插件指定 Maven 插件编译版本，使用 java8 语言，JVM1.8 编译，编译时使用UTF-8编码。 resources：项目资源列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。如下面就把文件 version.txt、banner.txt 和 templates/index.html 打包到 target 目录 12345678910111213141516171819202122232425262728293031323334&lt;build&gt; &lt;finalName&gt;sale-api&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;includeSystemScope&gt;true&lt;/includeSystemScope&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;$&#123;project.basedir&#125;/src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;version.txt&lt;/include&gt; &lt;include&gt;banner.txt&lt;/include&gt; &lt;include&gt;templates/index.html&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; properties：POM 定义的常量，可供 POM 文件的其他地方引用，格式是 &lt;name&gt;value&lt;/name&gt;，引用时通过 ${name} 来获取 value 的值。如下面可以通过 ${file.encoding} 来获取值 UTF-8，还可以使用 project.xx 引用 POM 里定义的其它属性：如 $(project.version}。 12345&lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file_encoding&gt; &lt;Java.source.version&gt;1.5&lt;/java_source_version&gt; &lt;java.target.version&gt;1.5&lt;/java_target_version&gt; &lt;/properties&gt; repositories：远程仓库列表，当 Maven 在本地仓库和中央仓库中找不到所需要的依赖包时就会去远程仓库查找，可通过 &lt;repository&gt; 定义多个远程仓库。 123456789101112&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;spring-releases&lt;/id&gt; &lt;name&gt;Spring Releases&lt;/name&gt; &lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;org.jboss.repository.releases&lt;/id&gt; &lt;name&gt;JBoss Maven Release Repository&lt;/name&gt; &lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt; 标签详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符 --&gt; &lt;artifactId /&gt; &lt;!--被继承的父项目的全球唯一标识符 --&gt; &lt;groupId /&gt; &lt;!--被继承的父项目的版本 --&gt; &lt;version /&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven&gt;&lt;/maven&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息 --&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!--使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!--构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!--构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!--构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt; &lt;finalName /&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表 --&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;!-- 以下为插件示例 --&gt; &lt;!-- 指定maven插件编译版本，使用java8语言，JVM1.8编译，编译时使用UTF-8编码 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 启动jar插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.0.RELEASE&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;classifier&gt;server&lt;/classifier&gt; &lt;mainClass&gt;com.xx.xxxx.server.startup.StmsStartup&lt;/mainClass&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!-- 声明变量，当该profile被激活时，可以用$&#123;env&#125;引入值 --&gt; &lt;properties&gt; &lt;!-- env为key（自定义的），相当于声明变量:env=dev --&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 &apos;windows&apos;) --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt; &lt;finalName /&gt; &lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules&gt;&lt;/modules&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties&gt;&lt;/properties&gt;&lt;/project&gt; 参考Maven 详解Maven学习-目录结构Maven 的 pom 文件详细解析Maven 中 pom 文件详解]]></content>
  </entry>
  <entry>
    <title><![CDATA[实用学习网址汇总]]></title>
    <url>%2F2018%2F06%2F25%2F%E7%BD%91%E5%9D%80%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[在学习的过程中遇到很多有实用干货的文章和一些很实用的工具性网站，如果每读完一篇博客后都要写一篇博客来进行知识总结未免太耗费时间，在这里将这些实用的文章和工具性网站进行汇总，方便以后查找资料。 系统LinuxLinux命令大全 编程语言JAVAJava8 官方手册Java8 官方手册中文版-谷歌版Java8 官方手册中文版-有道版Java8 官方手册中文版-百度版MAC 安装 JDK 及环境变量配置 数据库PostgreSQLPostgreSQL 官方文档PostgreSQL 教程-易百教程在 Mac OS X 上安装 PostgreSQL Mongodb介绍一款好用 mongodb 可视化工具 实用工具Git常用 Git 命令清单Git 工作流程Git 使用规范流程廖雪峰 Git 教程 MavenMaven 官方文档Maven 中央仓库Maven 教程-易百教程Mac 安装 MavenMaven 详解 MarkdownMarkdown 官方中文手册Markdown 语法整理大集合2017Markdown 语法手册 （完整整理版）]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>实用工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo问题及解决办法汇总]]></title>
    <url>%2F2018%2F06%2F25%2FHexo%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[对通过 Hexo 搭建博客过程中遇到的问题进行了汇总，以后再遇到相同的问题可以迅速定位解决问题。 搜索问题点击 Local Search 本地搜索页面卡住问题描述：安装教程配置好 Local Search 本地搜索之后，点击 搜索 按钮页面一直卡在转圈圈的地方，F12进入开发者工具没有看到错误提示，以 debug 模式启动的服务器也没有错误输出？ 问题解决：出现这种情况是因为你的某一篇文章中出现了非 UTF-8 编码的字符，解决办法是 找到把该异常字符并删除。 打开 http://localhost:4000/search.xml，确认错误字符所在的位置。如下图所示就在 第6行第35列 通过 $ vim public/search.xml 打开 search.xml 文件，根据刚才的位置定位到出现问题的文章的该行该列。该位置一般会出现一个异常字符，例如 ^H 或者 ^M 等字符。注意不用直接修改 search.xml 文件。 编辑出现问题的文章的 md 文件，找到出现问题的行列，把该位置的特殊字符删掉。该字符有可能是一个隐藏的字符如 ^H，一般的 markdown 编辑工具可能看不到该字符，可以通过 vim 编辑删除该字符。 执行 $ hexo clean &amp;&amp; hexo g 后重启服务器，然后再打开 http://localhost:4000/search.xml，看到下图所示表示可以正常使用本地搜索功能。 部署问题在执行 hexo d 部署到 GitHub 上的时候总是卡住问题描述：在执行 hexo d 部署到 GitHub 上的时候总是卡住没有往下面执行，这时候只能 ctrl + c 中断或等待很久一段时间后才执行完毕。 问题解决：这是由于国内墙对 GitHub 的阻挡影响，导致国内用户在向 GitHub 仓库 pull 或者 push 的时候速度都会受到不同程度的影响。解决办法是 买或者自己搭建个 vpn，然后设置 git 代理。 1234567891011121314// 查看当前代理设置git config --global http.proxygit config --global https.proxy// 设置当前代理为 http://127.0.0.1:1080 或 socket5://127.0.0.1:1080git config --global http.proxy &apos;http://127.0.0.1:1080&apos;git config --global https.proxy &apos;http://127.0.0.1:1080&apos;git config --global http.proxy &apos;socks5://127.0.0.1:1080&apos;git config --global https.proxy &apos;socks5://127.0.0.1:1080&apos;// 删除 proxygit config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>问题汇总</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义tabBar]]></title>
    <url>%2F2018%2F06%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89tabBar%2F</url>
    <content type="text"><![CDATA[tabBar 是指小程序底部的导航栏，微信小程序官方提供了 多 tabBar 设置，但是官方提供的 tabBar 最多支持 5 个 tab，而且是全局共用的，这意味着并不支持 有时候我们想跳到不同的页面显示不同的 tabBar 导航栏 这样的功能。所以本人尝试着手实现自定义的 tabBar 导航栏。转载请说明出处。 实现思路参考过网上自定义 tabBar 的一些资料，例如这位仁兄的 微信小程序自定义tabBar组件开发，发现大部分资料都是 通过 navigateTo 的方式进行 tab 切换。这种实现方式有一个很明显的缺点：在 tab 切换的时候整个页面都会刷新一次，这意味着页面底下的 tabBar 导航栏也会跟着刷新，这样会很影响用户体验。官网的 tabBar 导航栏是在底层实现，所以不会出现这种刷新情况。 因为没有办法解决这种通过 navigateTo 实现 tabBar 的刷新问题，本人转换了一种思路。这种办法适合于每个 tab 页面数据量不是很大的情况，如果你每个页面的数据量都非常大而且需要实时刷新的话可能不太适合这种方法。 所有的 tab 页面和底下 tabBar 导航栏都写在同一个 wxml 页面里面，每个 tab 页面跟导航栏的一个按钮对应。 在打开页面时所有 tab 页面的数据通过一个路由取回，然后渲染到各个 tab 页面里面。然后只把第一个 tab 页面的内容显示出来，其他 tab 页面都隐藏。 每次点击下面的 tabBar 导航栏，只把点击按钮对应的 tab 页面显示出来，其他的 tab 页面都隐藏。 这样实现的好处是 tab 切换时底部导航栏不会刷新，而且切换非常流畅，缺点是切换时 tab 页面不能实现实时刷新。如果你觉得这种实现方法能满足你的需求，请继续往下看。 实现过程下面显示每部分的核心代码。 wxml12345678910111213141516171819202122232425&lt;view class=&apos;container&apos;&gt; &lt;view class=&apos;del-list&apos;&gt; &lt;view class=&quot;page__bd&quot;&gt; &lt;block wx:if=&apos;&#123;&#123;tabbarIndex == 0&#125;&#125;&apos;&gt; // tab 页面1代码 &lt;/block&gt; &lt;block wx:if=&apos;&#123;&#123;tabbarIndex == 1&#125;&#125;&apos;&gt; // tab 页面2代码 &lt;/block&gt; &lt;/view&gt; &lt;/view&gt; &lt;!--自定义导航栏--&gt; &lt;view class=&apos;tabbar&apos;&gt; &lt;view class=&apos;tabbar-box&apos;&gt; &lt;view class=&apos;tabbar-item&apos; wx:for=&quot;&#123;&#123;tabbarList&#125;&#125;&quot; bindtap=&apos;tapTabbar&apos; id=&quot;&#123;&#123;item.index&#125;&#125;&quot;&gt; &lt;view class=&apos;tabbar-item-icon&apos;&gt; &lt;image src=&apos;&#123;&#123;item.icon&#125;&#125;&apos;&gt;&lt;/image&gt; &lt;/view&gt; &lt;view class=&apos;tabbar-item-text&apos;&gt;&#123;&#123;item.text&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/view&gt; &lt;/view&gt;&lt;/view&gt; 底部导航栏为 tabbarList 的一个 list 数组，每个 tab 页面的 tabbarIndex 跟 list 数组的 index 对应。这样就可以根据 index 来显示对应的 tab 页面。 js12345678910111213141516171819202122232425262728293031323334353637383940414243444546Page(&#123; data: &#123; ...... tabbarList: [&#123; index: 0, icon: &apos;/images/driver/deliver-select.png&apos;, text: &apos;发货单&apos; &#125;, &#123; index: 1, icon: &apos;/images/driver/my.png&apos;, text: &apos;我的&apos; &#125;], tabbarIndex: 0, &#125;, /** * 点击tabbar导航栏 */ tapTabbar: function(e) &#123; var index = e.currentTarget.id var tabbarList = this.data.tabbarList for (var item in tabbarList) &#123; if (tabbarList[item].index == index) &#123; var icon = tabbarList[item].icon var iconList = icon.split(&apos;.&apos;) if(iconList[0].indexOf(&apos;select&apos;) &lt; 0) &#123; tabbarList[item].icon = iconList[0] + &apos;-select.&apos; + iconList[1] &#125; &#125;else &#123; var icon = tabbarList[item].icon var iconList = icon.split(&apos;.&apos;) if (iconList[0].indexOf(&apos;select&apos;) &gt; 0) &#123; var temp = iconList[0].replace(/-select/g, &apos;&apos;) tabbarList[item].icon = temp + &apos;.&apos; + iconList[1] &#125; &#125; &#125; this.setData(&#123; tabbarList: tabbarList, tabbarIndex: index &#125;) &#125;, ......&#125;) 点击 tabBar 导航栏时，把当前点击按钮的图片更新为带 -select 后缀表示选中的图片，其他的按钮图片更新为无后缀图片，然后重新渲染 tabbarList 和 tabbarIndex。 wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445.......tabbar &#123; position: fixed; z-index: 999; bottom: 0; width: 100%; height: 120rpx; background-color: #f8f8f8; border-top: 1rpx solid #d9d9d9&#125;.tabbar-box &#123; display: flex; align-items: center; justify-content: center&#125;.tabbar-item &#123; display: flex; flex-direction: column; text-align: center; justify-content: center; margin-top: 10rpx; width: 50%&#125;.tabbar-item image &#123; width: 65rpx; height: 65rpx;&#125;.tabbar-item-icon &#123; height: 65rpx&#125;.tabbar-item-text &#123; font-size: 28rpx; color: #999&#125;.del-list-logout &#123; width: 90%; margin: 50rpx auto 0&#125; tabBar 图片 实现效果]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo个人博客绑定域名]]></title>
    <url>%2F2018%2F06%2F24%2FHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BB%91%E5%AE%9A%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[Hexo + Github 搭建的个人博客访问地址默认为 yourname.github.io，这种地址一方面由于太长不容易被人记住，另一方面也难以被谷歌、百度等搜索引擎收录。所以我们可以申请独立的域名指向我们的博客地址，转载请说明出处。 域名目前国内有万网、新网等域名服务商，下面以 万网 为例子说明 购买域名登陆 万网官网，申请阿里云账号，然后在 域名注册 页面购买自己的域名 按照工信部 2017 年全面域名实名认证的要求,若域名在规定时间内未通过实名审核，会被注册局暂停解析（Serverhold），无法正常访问，待实名认证通过后方可恢复正常使用。实名认证流程为： 登录 阿里云域名控制台，单击 域名列表 页面的 未实名认证域名 &gt; 提交资料 。 填写实名认证资料，单击 提交 。 域名解析在 域名列表 里面找到你注册成功且通过实名认证可正常使用的域名，点击 解析 按钮（未实名认证状态异常的域名可能没有该按钮） 在 解析设置 界面点击右上角 添加记录，填写内容 记录类型：CNAME 类型将该域名指向你的 yourname.github.io，也可以用 A类型指向 ip 地址：先 ping 你的 yourusername.github.io，用 A 类型指向 ping 得到的 ip 地址。 主机记录：www 解析后的域名为 www.aliyun.com, @ 直接解析主域名 aliyun.com。一般写这两个就行。 记录值：CNAME 解析对应 yourname.github.io，A 解析对应 ip 地址。 添加成功后如下图所示： Hexo我们要在上传到 GitHub 的静态文件夹里面添加 CNAME 解析文件，对应上面添加的 CNAME 解析记录。 创建 CNAME 文件我们在站点目录的 source 文件夹下面创建 CNAME 文件，这样每次我们生成静态文件的时候都会自动把该文件添加到 public 文件夹。 12$ cd source$ vim CNAME 注意文件名就是 CNAME，不能写错，在文件中添加你注册的域名如下 1mcbill.cn 注意域名前面不用加任何前缀，保存退出。 发布部署1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署成功再过几分钟访问你的域名，如 mcbill.cn 解析成功就会跳转到你的博客。以后就算是直接访问 yourname.github.io 也会直接解析为你的域名。至此 绑定域名已经完成。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多台电脑更新博客]]></title>
    <url>%2F2018%2F06%2F22%2FHexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[通过 Hexo 和 GitHub 搭建的博客，静态文件会上传到 GitHub 仓库的 master 分支，但是 Hexo 的安装目录还是保存在本地的。如果更换了电脑需要更新博客，我们需要 Hexo 的安装目录来生成/编辑/上传博客，并且这个安装目录需要随着博客的更新而更新。在这里提供一种便捷的办法来实现不同电脑之间同步更新博客。转载请说明出处。 实现思路在 Github 用于存放博客的仓库 yourname.github.io 下面建立 master 和 hexo 两个分支 master 分支（默认创建），通过 Hexo 命令提交，用于存放上传的 Hexo 静态文件（例如 public 文件夹里面的内容），这个分支用于显示 https://yourname.github.io 打开的内容。 hexo 分支（手动创建），通过 Git 命令提交/拉取，用于存放 Hexo 的安装目录，该分支可设为 默认分支 。 这样我们写博客的大概流程就是 在 hexo 分支上写上博客，并把写好的博客内容上传到 master 分支，两个分支都通过 git 进行管理，所有的修改一目了然，非常方便。 实现过程本地电脑如果你的电脑还没配置好 Hexo，请参考以前的教程 Hexo+GitHub搭建个人博客教程当你本地电脑的 Hexo 目录已经安装配置完毕之后，该目录可以 通过 Hexo 命令向 GitHub 仓库的 master 分支提交内容，但是该目录还不是 git 管理的目录，需要把该目录初始化为 git 管理的目录。 1、删除非默认主题文件的 .git 目录（可跳过）如果你使用的是非默认主题 landscape 的其他主题，而该主题的目录也是在通过 git clone 方式拉取下来的话，需要先取消该目录的 git 管理追踪，否则到时候提交 Hexo 安装目录的时候该文件夹会报类似于 XXX目录: git modified content untracked content 的错误。例如本人使用的是 next 主题，在 Hexo 安装目录下输入命令： 1234$ cd themes/next$ ls -la # 显示 .git 的隐藏目录$ rm -rf .git$ ls -la # 确认 .git 目录是否成功删除 2、把 Hexo 命令提交的分支改成 master 分支编辑 Hexo 安装目录下的 _config.yaml 文件，在 deploy 参数里面添加 branch: master，如下 1234deploy: type: git repo: https://github.com/yourusername/yourusername.github.io.git branch: master 3、初始化 git 仓库在 Hexo 安装目录下输入命令 1234$ git init$ git checkout -b hexo$ git add .$ git commit -m &apos;init&apos; 初始化为 git 目录并创建 hexo 分支 4、提交到远端服务器在 Hexo 安装目录下输入命令 12$ git remote add origin git@github.com:yourusername/yourusername.github.io.git$ git push -u origin hexo:hexo 与远端主机关联并提交 hexo 分支 另外一台电脑当你在一台新电脑上需要写博客的时候，需要先把 hexo 分支拉取下来，再进行 Hexo 初始化。前提是该电脑需要先安装 git 和 node.js，并与 GitHub 进行 ssh 关联（可选）。如果这些工作还没完成请参考 Hexo+GitHub搭建个人博客教程 1、拉取 hexo 分支在任意目录里面输入命令 1$ git clone -b hexo git@github.com: yourusername/yourusername.github.io.git 执行完之后你的目录下应该会出现一个 yourusername.github.io 的目录。 2、初始化为 Hexo 目录yourusername.github.io 目录只是一个普通的 git 管理目录，需要把该目录初始化为 Hexo 目录。 1234$ cd yourusername.github.io$ npm install hexo$ npm install$ npm install hexo-deployer-git 3、安装插件（可跳过）12$ npm install hexo-generator-searchdb --save # 安装本地搜索$ npm install hexo-asset-image --save # 安装图片插件 至此这台新电脑的初始化工作也已经完成，可以开始写博客了。 写博客步骤以后我们写博客都在 hexo 分支下进行，master 分支只是用来存放生成的静态文件。确认目前在 hexo 分支下，步骤如下： git pull 每次写博客前拉取最新的 hexo 分支代码 hexo new post &#39;新文章&#39; 开始写博客 hexo clean &amp;&amp; hexo g 清空并生成新的静态文件和缓存文件 git add . git commit -m &#39;备注&#39; git push 提交到 hexo 分支 hexo d 提交到 master 分支 至此我们就可以实现在多台电脑上同步更新博客 参考资料Git远程操作详解GitHub Pages + Hexo搭建博客原git中status指令总是提示内容被修改的解决hexo本地测试运行重启后页面空白]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo插入图片和设置图片大小]]></title>
    <url>%2F2018%2F06%2F21%2Fhexo%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%9B%BE%E7%89%87%E5%A4%A7%E5%B0%8F%2F</url>
    <content type="text"><![CDATA[Hexo 插入图片有两种方式，第一种是网络引用，第二种是本地插入，本文主要介绍本地插入图片方式。另外由于 Hexo 是静态博客框架，所插入的图片默认会按照本身大小自动铺满，如果要设置图片大小需要另外写 css 来进行控制。转载请说明出处。 前言Hexo 插入图片有 网络图片插入 和 本地图片插入 两种方式。 网络图片插入的做法是先把图片上传到 七牛云 等云服务商提供的图床，然后通过 ![img-title](img-url) 的方式，把 img-url 的地址替换成图片在图床的 url 地址即可。使用网络图片的好处是七牛云的cdn加速效果会大大提高图片的打开速度，缺点是多图片博客的编辑过程会比较繁琐，图片管理比较麻烦。 本地图片插入把图片和博客保存在一起，方便图片管理，但是图片的网络打开速度会很慢。下面重点介绍本地图片插入。 常规本地图片插入1、修改配置文件编辑 hexo安装目录下的_config.yml 文件，找到 post_asset_folder，把值改成 true。 通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开资源文件管理功能。当资源文件管理功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 在建立文件时，Hexo会自动建立一个与文章同名的文件夹，您可以把与该文章相关的所有资源都放到那个文件夹，如此一来，您便可以更方便的使用资源。 2、安装插件安装插件 hexo-asset-image，在 hexo 安装目录下运行 1$ npm install hexo-asset-image --save 安装完成后需要重启一下服务器 3、使用插入图片使用 hexo new post &quot;xxxx&quot; 来新建博客时，会发现在 /source/_posts 文件夹下会有一个同名的 xxxx 文件夹，对于已存在的博客可以新建一个同名文件夹。 先把图片复制到同名文件夹中，然后在文章中使用 1![图片替代文字](img.jpg) 注意 img.jpg 前面的路径只需要同名文件夹的名称即可，不需要写什么绝对路径、相对路径。如我要引用 example.jpeg 图片，只需要把 example.jpeg 复制到同名文件夹，然后在文章中使用 1![赵霁](example.jpeg) 效果图如下： 设置图片大小图片默认会显示原本的图片大小并居中显示，如果需要对图片大小进行设置，需要另外写 css 样式进行控制。注意：该方法可能会覆盖原来的一些图片样式。 1&lt;div style=&quot;width: 200px; margin: auto&quot;&gt;![赵霁](example.jpeg)&lt;/div&gt; 设置宽度为200px并设置居中（高度会自动缩放），效果图如下： 参考Hexo 官方文档资源文件夹hexo博客图片问题hexo生成博文插入图片]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序自定义Modal组件]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%AE%9A%E4%B9%89Modal%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在小程序 官方文档 中可以使用 wx.showModal() 方法来生成 Modal 蒙层弹框，但是其显示的内容只能为文本格式且由传入参数限定，显示方式比较单一，不能满足日常多样化的需求。本人查阅了相关资料完成一些自定义Modal组件，可以满足个性化需求。转载请说明出处。 实现思路在这里的实现思路主要是通过微信小程序的原生 Modal 组件来实现，这个组件在最新版的官方文档中已经找不到，估计官方是想用 wx.showModal() 方法来代替使用，但是仍然可以向下兼容使用。通过原生的 Modal 组件我们可以自定义自己的内容界面，Modal 组件的 api 文档如下 再对比 wx.showModal() 的 api 文档不难看出其只是对 Modal 组件的进一步封装。 源码wxml1234567891011121314151617181920212223242526272829......&lt;!--打印发货单蒙层--&gt; &lt;modal hidden=&quot;&#123;&#123;hideModal&#125;&#125;&quot; class=&apos;modal&apos; cancel-text=&apos;返回&apos; confirm-text=&apos;下一步&apos; bindcancel=&quot;cancelPrint&quot; bindconfirm=&quot;confirmPrint&quot; catchtouchmove=&apos;preventTouchMove&apos;&gt; &lt;view class=&apos;modal-box&apos;&gt; &lt;radio-group bindchange=&apos;radioChange&apos;&gt; &lt;label class=&apos;radio modal-item&apos;&gt; &lt;view class=&apos;modal-item-hd&apos;&gt; &lt;radio value=&apos;1&apos; checked=&apos;&#123;&#123;radioIndex == 1&#125;&#125;&apos;&gt;&lt;/radio&gt; &lt;view&gt;根据手机号和提货码发货&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;modal-item-bd&apos;&gt; &lt;view&gt;手机号：&#123;&#123;phone&#125;&#125;&lt;/view&gt; &lt;view&gt;提货码：&#123;&#123;detail.ladingCode&#125;&#125;&lt;/view&gt; &lt;/view&gt; &lt;/label&gt; &lt;label class=&apos;radio modal-item&apos;&gt; &lt;view class=&apos;modal-item-hd&apos;&gt; &lt;radio value=&apos;2&apos;&gt;&lt;/radio&gt; &lt;view&gt;扫描二维码&lt;/view&gt; &lt;/view&gt; &lt;view class=&apos;modal-item-bd&apos;&gt; &lt;view&gt;请点击下一步&lt;/view&gt; &lt;/view&gt; &lt;/label&gt; &lt;/radio-group&gt; &lt;/view&gt; &lt;/modal&gt;...... wxml文件最关键部分是 &lt;modal&gt;&lt;/modal&gt; 组件的调用，参数解析如下 通过 hidden 属性来控制蒙层的显示和隐藏 bindcancel 属性绑定返回时间 bindconfirm 属性绑定确认事件 catchtouchmove 防止触摸滑动穿透，即当 modal 弹层下的页面有滚动条，在 modal 弹层上触摸滑动时下面的页面仍跟着滚动的情况。 js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263data: &#123; phone: null, detail: null, hideModal: true, radioIndex: 1&#125;,....../** * 显示modal组件 */printDel: function() &#123; this.setData(&#123; hideModal: false &#125;)&#125;,/** * 隐藏modal组件 */cancelPrint: function() &#123; this.setData(&#123; hideModal: true &#125;)&#125;,/** * 阻断蒙层事件向下传递 */preventTouchMove: function() &#123;&#125;/** * 选择打印发货单方式 */radioChange: function(e) &#123; this.setData(&#123; radioIndex: e.detail.value &#125;)&#125;,/** * 确认打印 */confirmPrint: function() &#123; var radioIndex = this.data.radioIndex if(radioIndex == 1) &#123; //根据手机号和提货码发货 wx.showToast(&#123; title: &apos;请在终端屏幕上输入手机号和提货码&apos;, icon: &apos;none&apos; &#125;) &#125;else &#123; //扫描二维码 /** code */ this.setData(&#123; hideModal: true &#125;) &#125;&#125;,.... js 文件中最关键的是 this.setData({ hideModal: true / false }) 来控制 Modal 组件的隐藏/显示，以及空方法 preventTouchMove() 阻止事件向父节点传递。 以bind或catch开头，然后跟上事件的类型，bind事件绑定不会阻止冒泡事件向上冒泡，catch事件绑定可以阻止冒泡事件向上冒泡。 详见 小程序事件 wxss12345678910111213141516171819.......modal-item-hd &#123; display: flex; align-items: center&#125;.modal-item-hd view &#123; font-size: 32rpx; color: #000; padding-top: 5rpx&#125;.modal-item-bd &#123; margin: 10rpx 0 20rpx 60rpx; font-size: 36rpx;&#125;...... wxss比较简单，在这里不做详细解析。 最终效果 参考文档自定义模态对话框实例微信小程序之—-弹框组件modal小程序 实现遮罩层]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
        <tag>Modal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题配置]]></title>
    <url>%2F2018%2F06%2F17%2Fnext%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[NexT 是 Hexo 下最热门的主题之一，下面简单简介 NextT 主题的配置，在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件，后者称为 主题配置文件。转载请说明出处。 一、安装NextT1、下载主题把主题文件下载到安装目录的 theme 目录下12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2、启用主题打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。1theme: next 到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 hexo clean 来清除 Hexo 的缓存。 注意：修改 站点配置文件 需求重启服务器才能生效，修改 主题配置文件 不需要重启服务器。重启步骤为在服务器启动控制台 ctrl + c，然后 $ hexo server [--debug] 二、主题设置1、外观 scheme 设置修改 主题配置文件，查找 scheme 关键字，将你需用启用的 scheme 前面注释 # 去除即可 Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白 Mist - Muse 的紧凑版本，整洁有序的单栏外观 Pisces - 双栏 Scheme，小家碧玉似的清新 Gemini - 紧凑集中版双栏 Scheme，本网站采用的主题 12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 2、语言 language 设置编辑 站点配置文件 （针对所有主题下的文件）或 主题配置文件 (针对本主题下的文件)下的 language，例如启用简体中文就改成 zh-Hans1language: zh-Hans 3、设置菜单启用/禁用菜单编辑 主题配置文件，设定菜单内容，对应的字段是 menu。 菜单内容的设置格式是：item name: link。其中 item name 是一个名称，这个名称并不直接显示在页面上，她将用于匹配图标以及翻译。把需要启动的菜单项前面的 # 去掉。也可以新增自定义菜单项。 123456789menu: home: / || home # about: /about/ || user tags: /tags/ || tags categories: /categories/ || th # archives: /archives/ || archive # schedule: /schedule/ || calendar # sitemap: /sitemap.xml || sitemap # commonweal: /404/ || heartbeat 默认的菜单项如下： 键值 设定值 显示文本（简体中文） home home: / 主页 archives archives: /archives 归档页 categories categories: /categories 分类页 tags tags: /tags 标签页 schedule schedule: /schedule 日程表 about about: /about 关于 sitemap sitemap: /sitemap 站点地图 commonweal commonweal: /404.html 公益 404 其中除了 home 和 archives 页面，其他页面都需要手动创建，例如新建 tags 页面 切换到 Hexo 根目录下，使用 hexo new page tags 新建 tags 页面 编辑 /source/tags/index.md 文件，在头文件部分 front-matter 添加 type: &quot;tags&quot;，如需要关闭评论添加 comments: false 设置菜单显示文字修改 languages/{language}.yml 文件，如果简体中文对应 languages/zh-Hans.yml 文件下的 menu 字段 12345678910menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 修改字段值直接影响页面上菜单文字显示，或者新增字段值，字段名要与上面第一步设置的自定义菜单名称对应。 4、设置侧栏修改 主题配置文件 文件中的 sidebar 字段 设置侧栏位置 left - 靠左放置 right - 靠右放置 12sidebar: position: left 设置侧栏显示的时机 post - 默认行为，在文章页面（拥有目录列表）时显示 always - 在所有页面中都显示 hide - 在所有页面中都隐藏（可以手动展开） remove - 完全移除 12sidebar: display: post 5、设置头像修改 主题配置文件 下的 avatar 字段，设成头像的链接1avatar: images/avatar.png 6、设置作者昵称编辑 站点配置文件，设置 author 字段 7、设置站点名称编辑 站点配置文件，设置 description 字段 8、设置社交编辑 主题配置文件 设置社交链接修改 social 字段，其键值格式是 显示文本: 链接地址。 1234567891011social: GitHub: https://github.com/18814122746 || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 设置链接图标修改 social_icons: 字段，其键值格式是 匹配键: Font Awesome 图标名称，匹配键 与上一步所配置的链接的 显示文本 相同（大小写严格匹配） 1234567# Social Iconssocial_icons: enable: true # Icon Mappings GitHub: github Twitter: twitter 微博: weibo 9、设置背景动画NexT 自带 canvas_nest 和 three_waves 两种背景动画效果，编辑 主题配置文件 将对应的字段改成 true 或 false 即可，只能同时开启一种背景动画效果。 12canvas_nest: true#three_waves : false 三、第三方插件1、安装评论系统理论上 Hexo 支持 DISQUS、Facebook Comments、HyperComments、Gitment、网易云跟帖、搜狐畅言、友言和来必力等评论插件，其中 DISQUS、Facebook Comments 需要翻墙才能评论，Hypercomments 目前只剩下收费版本，Gitment 需要用 GitHub 账号登陆才能评论，搜狐畅言 需要网站备案才能使用，网易云跟帖、友言 已经停止服务。综合考虑选择 来必力 作为我们的评论系统。 登陆 来必力官网 注册账号 点击 右上角头像 &gt; 管理页面，安装 City 免费版 打开 管理页面 中的 代码管理，复制 data-uid 中的值 编辑 主题配置文件 中的 livere_uid 字段，把刚才复制的 data-uid 的值粘贴进去 2、统计访问次数有 百度统计 和 不蒜子 统计两种方式。两者的区别是：前者可以用来后台统计，数据比较准确可靠；后者用来在页面上显示，根据访问 ip 进行粗略统计。 百度统计 登陆 百度统计官网，注册账号 获取代码点击 管理 &gt; 代码管理 &gt; 代码获取，找到类似于 hm.src = &quot;https://hm.baidu.com/hm.js?xxx&quot;; 的代码，复制 .js? 后面的统计脚本id 编辑 主题配置文件 中的 baidu_analytics 字段，把刚才粘贴的值粘贴进去 不蒜子统计编辑 主题配置文件 中的 busuanzi_count 参数，如下所示 1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 总访问人数 site_uv_footer: 人 # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 本文阅读量 page_pv_footer: 次 当 site_uv: true 时，代表在页面底部显示站点的UV值。 当 site_pv: true 时，代表在页面底部显示站点的PV值。 当 page_pv: true 时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 pv的方式，单个用户连续点击n篇文章，记录n次访问量。uv的方式，单个用户连续点击n篇文章，只记录1次访客数。 3、百度分享编辑 主题配置文件 中的baidushare 字段，改成 123baidushare: type: button baidushare: true 注意：百度分享不支持 Https，打开开发工具控制台可能会看到 Failed to load resource 的错误信息，原因是通过 Https 请求百度分享的 Http 资源时候被拒绝了。解决办法是直接把这些百度分享的资源文件放到自己的目录下，参考大佬的解决方案 百度分享不支持https的解决方案 下载资源文件，GitHub地址为 https://github.com/hrwhisper/baiduShare 把里面的 static 文件夹放在安装目录下的 source 文件夹里面 修改 你的安装目录/themes/next/layout/_partials/share/baidushare.swig 文件如下 123.src=&apos;http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt;改为.src=&apos;/static/api/js/share.js?v=89860593.js?cdnversion=&apos;+~(-new Date()/36e5)];&lt;/script&gt; 编辑 站点配置文件 中的 skip_render 字段，Hexo会禁止编译 skip_render 定义的文件/文件夹 1skip_render: static/** 重启服务器，最好执行一下 hexo clean 4、本地搜索 Local Search 安装 hexo-generator-searchdb，在安装目录下执行 1$ npm install hexo-generator-searchdb --save 编辑 站点配置文件，新增以下内容到任意位置： 12345search: path: search.xml field: post format: html limit: 10000 编辑 主题配置文件，查找 local_search 字段，把值改为 true 12local_search: enable: true 四、参考Hexo中文使用文档Hexo的Next主题详细配置hexo的next主题个性化教程：打造炫酷网站hexo添加评论功能hexo next主题为博客添加分享功能 Hexo+Github搭建个人博客(三)——百度分享集成为NexT主题添加文章阅读量统计功能]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>next</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+GitHub搭建个人博客教程]]></title>
    <url>%2F2018%2F06%2F13%2Fhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo 是一款基于 Node.js 的支持 Markdown 的静态站点生成框架，利用 Hexo+GitHub 可以轻松打造属于个人的免费博客。经过本人一番摸索最终搭建成功。本人的博客地址为 飙戈的博客，欢迎大家前来指导，转载请说明出处。 一、环境配置在搭建之前电脑需要的环境配置如下： git node.js github pages 仓库 我们可以在控制台中输入 12$ node -v$ git --version 如果没有报错则说明git和node.js已经安装成功，可直接跳过安装教程，如果报错则需要重新安装 1、安装git windows 用户：直接下载git安装程序根据提示进行安装 mac 用户：通过homebrew进行安装，没有安装的需要先安装homebrew，可以通过命令 $ brew install git 安装，也可通过下载 git安装程序 进行安装 linux 用户：通过命令行安装 $ sudo apt-get install git-core 安装完成后再在控制台输入 1$ git --version 如果没有报错则说明安装成功 2、安装node.js下载安装程序（推荐）直接下载 node.js安装程序 进行安装，比较快捷省事，适用于 mac 和 windows 用户 使用nvm安装cURL: 1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 安装完成后再在控制台输入 $ node -v 如果没有报错则说明安装成功 3、github pages我们用来托管博客的服务叫做 Github Pages，它是 Github 用来提供给个人/组织或者项目的网页服务，只需要部署到你的 Github Repository，推送代码，便可以实时呈现。 申请github账号首先你需要申请注册一个 github 账号 创建托管仓库点击右上角 New Repository 新建一个仓库来作为托管仓库，注意命名为 username.github.io（username是你的账号名)。 GitHub Pages 有两种类型：User/Organization Pages 和 Project Pages，两者的区别是： User Pages 是用来展示用户的，而 Project Pages 是用来展示项目的。 用于存放 User Pages 的仓库必须使用username.github.io的命名规则，而 Project Pages 则没有特殊的要求。 User Pages 将使用仓库的 master 分支，而 Project Pages 将使用 gh-pages 分支。 User Pages 通过 http(s)://username.github.io 进行访问，而 Projects Pages通过 http(s)://username.github.io/projectname 进行访问。 一般搭建个人博客都是用 User Pages，所以命名需要按照规范命名。 配置SSH（可跳过）SSH实现本地 git 项目和远程 github 的连接，github 通过 SSH 密钥识别特定的可信任电脑，该部分电脑在向 github 推送的时候不需要输入用户名和密码 查看电脑是否已经配置 ssh key 1$ ls -al ~/.ssh 默认情况下，public keys的文件名是以下的格式之一：id_dsa.pub、id_ecdsa.pub、id_ed25519.pub、id_rsa.pub。因此，如果列出的文件有public和private钥匙对（例如id_ras.pub和id_rsa），证明已存在SSH keys。如果提示 No such file or directory 则说明未安装 第一次安装完 git 需要先 初始化配置 git（可跳过） 12git config –global user.name &quot;yourusername&quot;git config --global user.email &quot;youremail@example.com&quot; 生成新的 SSH Key，输入密码之类的可以省略，一路回车就行 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 复制执行命令后显示的 key 内容 1cat ~/.ssh/id_rsa.pub 点击右上角的 Settings –&gt; SSH and GPG keys –&gt; New SSH key ，Title 自由填写，Key 粘贴刚才复制的那段代码，点击 Add SSH Key 测试连接 1$ ssh -T git@github.com 如果看到 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes，回车看到 12Hi username! You&apos;ve successfully authenticated, but GitHub does notprovide shell access. 表示连接成功，ssh的配置至此完成 二、安装Hexohexo的安装相当简单，在确保以上环境已经配置好的情况下 1、下载Hexo1$ npm install -g hexo-cli 有些教程会用命令 $ npm install -g hexo，作用同上，均为下载Hexo的安装包 2、初始化安装执行以下命令Hexo可把文件安装到指定文件夹 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建一个名为的文件夹（可带路径），通过 hexo init 初始化该文件夹，然后切换到该文件夹中，执行 npm install 进行安装 三、使用Hexo1、Hexo目录简介如果以上的安装成功，在安装目录下将会出现以下的文件结构 1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml：网站的全局配置文件 package.json：应用程序的信息 scaffolds：模版文件夹，Hexo的模板是指在新建的markdown文件中默认填充的内容。当您新建文章时，Hexo 会根据 scaffold 来建立文件。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source：资源文件夹，除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。例如用于域名解析的 CNAME 文件就可以放到该文件夹中，每次部署的时候都会自动添加该文件。 themes：主题文件夹，Hexo 会根据主题来生成静态页面。 2、启动输入命令 1$ hexo server 进行启动，可简化为 $ hexo s ，也可启动调试模式 $ hexo server --debug 3、创建文章执行以下命令可新建文章 1$ hexo new [layout] &lt;title&gt; 布局（layout）hexo有三种默认布局，用户也可以自定义布局，不同布局对应不同的存储路径 post：一般文章布局，自定义布局和post的对应的存储路径为 source/_posts page：页面布局，例如可以用于生成标签（tags）或分类（categories）等主页面，就是点击菜单直接显示的页面，对应的存储路径为 source draft：草稿布局，草稿默认不会显示在页面上，已完成的草稿可用 $ hexo publish [layout] &lt;title&gt; 来发布，对应的存储路径为 source/_drafts 标题（title）Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。其中 :title 默认会转为小写，空格将会被替换为短杠 例如新建一篇名为 hello world 的新文章 1$ hexo new post &quot;hello world&quot; source/_posts下面会自动生成一个名为 hello-world 的md文件（空格会自动转换为短杠），这就是我们新建的文章 4、编辑文章前页（Front-matter）Front-matter 是文件最上方以 — 分隔的区域，指定该文件的变量，支持的变量有： layout：布局 title：标题 date：建立日期，默认为文件建立日期 updated：更新日期，默认为文件更新日期 comments：开启文章的评论功能，默认为true tags：标签，不适用于布局为 page 的的页面 categories：分类，不适用于布局为 page 的的页面 permalink：覆盖文章网址 分类（categories）和标签（tags）的区别：分类具有顺序性和层次性，标签没有顺序和层次。例如 123categories:- Diary- Life 会使 Life 成为 Diary 的子类，而不是并列分类。 例如编辑一篇新文章的 front-matter 为 1234567891011---title: hello-worlddate: 2018-06-10 16:15:04categories:- Diary- Lifetags:- happy- friendcomments: false--- 首页显示部分内容首页默认会显示全部文章的全部内容，很多情况下我们只想在首页显示每篇文章的序言等部分内容，这样有利于读者总览。我们只需要在文章添加一句 &lt;!--more--&gt; 如下所示 123文章内容1&lt;!--more--&gt;文章内容2 &lt;!--more--&gt; 以上的内容1会在首页正常显示，以下的内容2会隐藏，并显示 阅读全文 等链接。 编辑字体颜色Hexo 通过 &lt;font&gt; 标签可实现自定义字体颜色和大小，color 属性定义字体颜色（不带引号），size 定义字体大小，如下： 1&lt;font color=#BF3EFF size=3&gt;粉色字体&lt;/font&gt; 效果图如下： 粉色字体 5、发布文章我们在本地编辑的文章只能在本地查看，如果想把文章发布到网上，我们需要把文章上传到上面配置好的 github pages 中。在发布文章前我们需要进行一些配置。 配置_config.yml文件编辑安装目录下的 _config.yml 文件，找到 deploy 参数，把 type 改成 git，repo 改成你自己的仓库地址，该地址可以直接上 github 上获取。 12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/18814122746/18814122746.github.io.git 注意：type: 和 git之间必须带一个空格 安装deployer工具hexo-deployer-git 为hexo自动部署安装工具，可通过命令安装 1$ npm install hexo-deployer-git --save 开始发布发布文章可分为 清空、生成 和 部署 三部分 清除缓存文件 (db.json) 和已生成的静态文件 (public)，执行命令 1$ hexo clean 生成public静态文件夹，执行命令 1$ hexo generate 也可简化成 $ hexo g 部署到 github 上面，执行命令 1$ hexo deploy 也可简化成 $ hexo d 执行完以上命令后，在浏览器输入 https://username.github.io 就可以浏览你的刚才发布的博客，例如本人的博客网址为 https://18814122746.github.io/ ，至此 Hexo + Github 的个人博客搭建已经完成。 6、Hexo常用命令汇总123456789$ hexo init [folder] #初始化 folder 文件夹为网站根目录，如果没有 folder 默认在目前的文件夹初始化$ hexo new &lt;title&gt; #新建文章$ hexo new page &lt;title&gt; #新建页面$ hexo server #启动服务器，默认情况下，访问网址为： http://localhost:4000/$ hexo clean #清空静态文件和缓存文件$ hexo generate #生成静态文件到public目录，可简写为 hexo -g$ hexo deploy #部署文件到远程服务器，可简写为 hexo -d$ hexo help #查看帮助$ hexo version #查看Hexo的版本 模式模式可配合上述命令行进行使用，例如 以调试模式启动服务器 $ hexo s --debug 安全模式，在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 1$ hexo --safe 调试模式，在终端中显示调试信息并记录到 debug.log。 1$ hexo --debug 简洁模式 1$ hexo --silent 参考链接Hexo官方中文文档HEXO搭建个人博客搭建个人博客-hexo+github详细完整步骤如何搭建一个独立博客——简明Github Pages与Hexo教程GitHub Pages + Hexo搭建博客使用Hexo搭建个人静态博客]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>教程</tag>
      </tags>
  </entry>
</search>
